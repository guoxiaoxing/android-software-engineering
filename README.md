#dagger2最佳实践

[Dagger2项目主页](http://google.github.io/dagger/)

##一 依赖注入原理

依赖注入到底是个什么概念呢？简单来说是将对象的生产和使用给分开了。比如说有一个Car对象，当你要出行的时候就自己new一个Car对象，
然后使用这个Car对象出行。在这里你出行的时候Car就是你的依赖，没有这个Car就无法出行，所以就自己来创建这个Car。如果使用依赖注入
了呢？创建和使用Car是分隔开的，创建的地方不考虑使用，使用的时候也不用考虑来创建，只要说我需要一辆Car，Dagger2就会自动帮你创建
好并让你使用。这就在一定程度上解耦了程序，让你的模块更加地可以重用。

##二 Dagger框架原理

Dagger2 通过注解来生成代码，定义不同的角色，主要的注解有：@Inject、@Module 、@Component 、@Provides 、@Scope 、@SubComponent 等。

- @Inject: 通常在需要依赖的地方使用这个注解。换句话说，你用它告诉Dagger这个类或者字段需要依赖注入。这样，Dagger就会构造一个这个类的实例并满足他们的依赖。
- @Module: Modules类里面的方法专门提供依赖，所以我们定义一个类，用@Module注解，这样Dagger在构造类的实例的时候，就知道从哪里去找到需要的 依赖。modules的一个重要特征是它们设计为分区并组合在一起（比如说，在我们的app中可以有多个组成在一起的modules）。
- @Provides: 在modules中，我们定义的方法是用这个注解，以此来告诉Dagger我们想要构造对象并提供这些依赖。
- @Component: Components从根本上来说就是一个注入器，也可以说是@Inject和@Module的桥梁，它的主要作用就是连接这两个部分。 Components可以提供所有定义了的类型的实例，比如：我们必须用@Component注解一个接口然后列出所有的　　 @Modules组成该组件，如 果缺失了任何一块都会在编译的时候报错。所有的组件都可以通过它的modules知道依赖的范围。
- @Scope: Scopes可是非常的有用，Dagger2可以通过自定义注解限定注解作用域。后面会演示一个例子，这是一个非常强大的特点，因为就如前面说的一样，没必要让每个对象都去了解如何管理他们的实例。
